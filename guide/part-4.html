<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="css/style.css">
  <link rel="stylesheet" type="text/css" href="css/syntax.css">
  <link href="https://fonts.googleapis.com/css?family=Cabin:700|Inconsolata:400,700|Open+Sans:400,700" rel="stylesheet">
  <title>THREEjs For Fun and Profit</title>
</head>

<body>

<header>
	<nav>
		<h3>Sections</h3>
		<a href='index.html'>Prerequisites</a>
		<a href='part-2.html'>3D Scene Structure</a>
		<a href='part-3.html'>Render Pipeline</a>
		<a href='part-4.html'>Loading Assets</a>
	</nav>
</header>
<span class='menu'></span>

<article>

	<h1>Loading Assets</h1>
	<img class='hero' src='img/scene.jpg'>
	<section><div class='content'>

	<p>THREEjs has a bunch of different helper functions for loading different types of assets. We still need to do bit of work however as network requests are asynchronous. We need to makes sure all our assets have loaded before we render anything otherwise WebGL will get mad at us an complain :( </p>

	</div></section>

	<section><div class='content'>

	<h3>Preloader</h3>

	<p>Our preloader works by incrementing a counter whenever we load an asset. Once loaded the counter is decremented and <code>check_is_loaded()</code> called. This function checks the counter and if it's zero runs <code>start()</code>.</p>

	</div></section>

	<section><div class='content'>

	<h3>Vertex Shader</h3>	

	<p>A vertex shader is responsible for taking the vertices of a mesh and moving them to their final position. The vertex shader is run once for every vertex that exists on the mesh.</p>

<pre><code class="glsl">//attribute vec3 position; -- supplied by THREE

//uniform mat4 modelMatrix; -- supplied by THREE
//uniform mat4 viewMatrix; -- supplied by THREE
//uniform mat4 projectionMatrix; -- supplied by THREE

void main()
{ 
	// position is turned into a vec4 first
	// the extra '1.0' on the end is needed
	// for the matrix math to work
	vec4 p = vec4(position, 1.0);
	
	// apply the objects movement transform
	p = modelMatrix * p;

	// apply the camera transform
	p = viewMatrix * p;

	// apply the camera perspective distortion
	p = projectionMatrix * p;

	gl_Position = p;
}
</code></pre>
<div class='caption'>Vertex Shader</div>

	<p>Behind the scenes transforms are stored as an array of 16 floats call a <strong>matrix</strong>. THREEjs automatically supplies some of the common matrices to the shader for us. Variables that we can supply to a shader are called <strong>uniforms</strong>.</p>

	</div></section>

	<section><div class='content'>

	<h3>Fragment Shader</h3>	

	<p>Any screen pixel that is covered by a triangle from the previous stage will trigger the execution of the fragment shader. It's here we can modify the colour and transparency of the result.</p>

	<pre><code class="glsl">
void main() 
{
	// output is RGBA
	gl_FragColor = vec4(1.0,1.0,1.0,1.0);
}
</code></pre>
<div class='caption'>Fragment Shader</div>

	</div></section>

	<section><div class='content'>

	<h3>Loading Shaders</h3>	

	<p>Loading shaders is.... a little fiddly, mainly because there are many ways to approach it. Firstly vertex and fragment shaders are separate programs you usually write and edit them as one file.

	One way of loading shaders is to fetch them as text files over the network using an AJAX request. Once we it has been loaded we can use THREEjs' built in functions to turn into a material. A material is a wrapper that stores and manages shader related things.</p>

	<pre><code class="glsl">
void main() 
{
	// output is RGBA
	gl_FragColor = vec4(1.0,1.0,1.0,1.0);
}
</code></pre>
<div class='caption'>Fragment Shader</div>

	</div></section>

</article>


<script src="js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>